{
  "address": "0x1797B1cD13ef35BD92Ef14Ca4dFa8f54B63e06fe",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_gaugeReference",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_gauge",
          "type": "address"
        }
      ],
      "name": "GaugeCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_reward",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_distributor",
          "type": "address"
        }
      ],
      "name": "createGauge",
      "outputs": [
        {
          "internalType": "address",
          "name": "newGauge",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gaugeReference",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb265cdd811bcb8b67003cbf075ed8f6a2846c28a3adab9ed3ec4ed1b4647b822",
  "receipt": {
    "to": null,
    "from": "0x40282d3Cf4890D9806BC1853e97a59C93D813653",
    "contractAddress": "0x1797B1cD13ef35BD92Ef14Ca4dFa8f54B63e06fe",
    "transactionIndex": 16,
    "gasUsed": "215031",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xfba259ada26cca188e736da706d6cf622fc994f352bc165b13d3422a3b2dd251",
    "transactionHash": "0xb265cdd811bcb8b67003cbf075ed8f6a2846c28a3adab9ed3ec4ed1b4647b822",
    "logs": [],
    "blockNumber": 7801178,
    "cumulativeGasUsed": "3513417",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xFD85D457De0532a7241abb34bee35b3Ee1e2c61c"
  ],
  "numDeployments": 1,
  "solcInputHash": "a4ba6f68672b10e4ca67083af5992942",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gaugeReference\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"GaugeCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reward\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"}],\"name\":\"createGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newGauge\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeReference\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Anyone can create gauges, but only some are added to the GaugeController\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_gaugeReference\":\"an existing gauge address\"}},\"createGauge(address,address,address)\":{\"details\":\"the owner of the new gauge will be msg.sender\",\"params\":{\"_distributor\":\"the GaugeDistributor address\",\"_reward\":\"reward token address\",\"_token\":\"deposit token address\"}}},\"version\":1},\"userdoc\":{\"events\":{\"GaugeCreated(address,address)\":{\"notice\":\"emitted when a new gauge is created\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"creates a new GaugeFactory contract\"},\"createGauge(address,address,address)\":{\"notice\":\"clones the gauge reference and initializes it with the new values\"},\"gaugeReference()\":{\"notice\":\"initial gauge reference that's being cloned\"}},\"notice\":\"Allows creating Liquidity gauges with a low cost\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/gauges/GaugeFactory.sol\":\"GaugeFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xae614c6b103b743c62e9544632f7ef4fc8950de4e9c783d2e765a3b86701dda3\",\"license\":\"MIT\"},\"contracts/gauges/GaugeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport '@openzeppelin/contracts/proxy/Clones.sol';\\r\\nimport './interfaces/ILiquidityGauge.sol';\\r\\n\\r\\n///@notice Allows creating Liquidity gauges with a low cost\\r\\n///@dev Anyone can create gauges, but only some are added to the GaugeController\\r\\ncontract GaugeFactory {\\r\\n    // ==========\\r\\n    // *DATA*\\r\\n    // ==========\\r\\n\\r\\n    /// @notice initial gauge reference that's being cloned\\r\\n    address public gaugeReference;\\r\\n\\r\\n    // ==========\\r\\n    // *EVENTS*\\r\\n    // ==========\\r\\n    /// @notice emitted when a new gauge is created\\r\\n    event GaugeCreated(address indexed _owner, address indexed _gauge);\\r\\n\\r\\n    // ==========\\r\\n    // * METHODS *\\r\\n    // ==========\\r\\n\\r\\n    ///@notice creates a new GaugeFactory contract\\r\\n    ///@param _gaugeReference an existing gauge address\\r\\n    constructor(address _gaugeReference) {\\r\\n        require(_gaugeReference != address(0), 'gauge not valid');\\r\\n        gaugeReference = _gaugeReference;\\r\\n    }\\r\\n\\r\\n    /// @notice clones the gauge reference and initializes it with the new values\\r\\n    /// @dev the owner of the new gauge will be msg.sender\\r\\n    /// @param _token deposit token address\\r\\n    /// @param _reward reward token address\\r\\n    /// @param _distributor the GaugeDistributor address\\r\\n    function createGauge(address _token, address _reward, address _distributor) public returns (address newGauge) {\\r\\n        newGauge = Clones.clone(gaugeReference);\\r\\n\\r\\n        ILiquidityGauge(newGauge).init(_token, _reward, msg.sender, _distributor);\\r\\n        emit GaugeCreated(msg.sender, newGauge);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xaec8003d7c60ca6b84b2aad3356ffcb7aa295811e43d933ab3316dec03bb6db4\",\"license\":\"UNLICENSED\"},\"contracts/gauges/interfaces/ILiquidityGauge.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// Liquidity gauge interface\\r\\ninterface ILiquidityGauge {\\r\\n    function init(\\r\\n        address _token,\\r\\n        address _reward,\\r\\n        address _owner,\\r\\n        address _distributor\\r\\n    ) external;\\r\\n\\r\\n    function addRewards(uint256 _amount) external;\\r\\n\\r\\n    function deposit(uint256 _amount) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xd1bbb336bf57fc32b21737967220577ddf012f8e271d85394d230622ca8c36c6\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161035538038061035583398101604081905261002f916100a0565b6001600160a01b03811661007b5760405162461bcd60e51b815260206004820152600f60248201526e19d85d59d9481b9bdd081d985b1a59608a1b604482015260640160405180910390fd5b600080546001600160a01b0319166001600160a01b03929092169190911790556100d0565b6000602082840312156100b257600080fd5b81516001600160a01b03811681146100c957600080fd5b9392505050565b610276806100df6000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80631c48e0fa1461003b5780639fc922c61461006a575b600080fd5b61004e6100493660046101fd565b61007d565b6040516001600160a01b03909116815260200160405180910390f35b60005461004e906001600160a01b031681565b60008054610093906001600160a01b0316610145565b6040516306552ff360e01b81526001600160a01b03868116600483015285811660248301523360448301528481166064830152919250908216906306552ff390608401600060405180830381600087803b1580156100f057600080fd5b505af1158015610104573d6000803e3d6000fd5b50506040516001600160a01b03841692503391507fbc0aff029cf899fe358381e295caa21dd2e8c1a6607e2b9e6c7ec915db15bd5390600090a39392505050565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b0381166101e15760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b604482015260640160405180910390fd5b919050565b80356001600160a01b03811681146101e157600080fd5b60008060006060848603121561021257600080fd5b61021b846101e6565b9250610229602085016101e6565b9150610237604085016101e6565b9050925092509256fea264697066735822122053a39f9734ab2e42e3d71c8fa9ec627ee1102643afe829c3a0b900cf4180373364736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80631c48e0fa1461003b5780639fc922c61461006a575b600080fd5b61004e6100493660046101fd565b61007d565b6040516001600160a01b03909116815260200160405180910390f35b60005461004e906001600160a01b031681565b60008054610093906001600160a01b0316610145565b6040516306552ff360e01b81526001600160a01b03868116600483015285811660248301523360448301528481166064830152919250908216906306552ff390608401600060405180830381600087803b1580156100f057600080fd5b505af1158015610104573d6000803e3d6000fd5b50506040516001600160a01b03841692503391507fbc0aff029cf899fe358381e295caa21dd2e8c1a6607e2b9e6c7ec915db15bd5390600090a39392505050565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528260601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09150506001600160a01b0381166101e15760405162461bcd60e51b8152602060048201526016602482015275115490cc4c4d8dce8818dc99585d194819985a5b195960521b604482015260640160405180910390fd5b919050565b80356001600160a01b03811681146101e157600080fd5b60008060006060848603121561021257600080fd5b61021b846101e6565b9250610229602085016101e6565b9150610237604085016101e6565b9050925092509256fea264697066735822122053a39f9734ab2e42e3d71c8fa9ec627ee1102643afe829c3a0b900cf4180373364736f6c63430008090033",
  "devdoc": {
    "details": "Anyone can create gauges, but only some are added to the GaugeController",
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_gaugeReference": "an existing gauge address"
        }
      },
      "createGauge(address,address,address)": {
        "details": "the owner of the new gauge will be msg.sender",
        "params": {
          "_distributor": "the GaugeDistributor address",
          "_reward": "reward token address",
          "_token": "deposit token address"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "GaugeCreated(address,address)": {
        "notice": "emitted when a new gauge is created"
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "creates a new GaugeFactory contract"
      },
      "createGauge(address,address,address)": {
        "notice": "clones the gauge reference and initializes it with the new values"
      },
      "gaugeReference()": {
        "notice": "initial gauge reference that's being cloned"
      }
    },
    "notice": "Allows creating Liquidity gauges with a low cost",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 6556,
        "contract": "contracts/gauges/GaugeFactory.sol:GaugeFactory",
        "label": "gaugeReference",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      }
    }
  }
}