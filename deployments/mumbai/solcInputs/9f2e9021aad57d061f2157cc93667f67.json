{
  "language": "Solidity",
  "sources": {
    "contracts/tokens/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/tokens/interfaces/ITapOFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITapOFT {\r\n    function extractTAP(address to, uint256 value) external;\r\n\r\n    function approve(address to, uint256 value) external;\r\n\r\n    function balanceOf(address user) external view returns (uint256);\r\n\r\n    function emissionsStartTime() external view returns (uint256);\r\n\r\n    function mintedInWeek(int256 week) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/tokens/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\nimport '@boringcrypto/boring-solidity/contracts/ERC20.sol';\r\n\r\ncontract ERC20Mock is ERC20WithSupply {\r\n    constructor(uint256 _initialAmount) {\r\n        totalSupply = _initialAmount;\r\n    }\r\n\r\n    function freeMint(uint256 _val) public {\r\n        _mint(msg.sender, _val);\r\n    }\r\n\r\n    function decimals() external pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function name() external pure returns (string memory) {\r\n        return 'Test Token';\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n        return 'TST';\r\n    }\r\n}\r\n"
    },
    "@boringcrypto/boring-solidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./interfaces/IERC20.sol\";\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable not-rely-on-time\n\n// Data part taken out for building of contracts that receive delegate calls\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\nabstract contract ERC20 is IERC20, Domain {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"ERC20: Invalid Signature\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n}\n\ncontract ERC20WithSupply is IERC20, ERC20 {\n    uint256 public override totalSupply;\n\n    function _mint(address user, uint256 amount) internal {\n        uint256 newTotalSupply = totalSupply + amount;\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\n        totalSupply = newTotalSupply;\n        balanceOf[user] += amount;\n        emit Transfer(address(0), user, amount);\n    }\n\n    function _burn(address user, uint256 amount) internal {\n        require(balanceOf[user] >= amount, \"Burn too much\");\n        totalSupply -= amount;\n        balanceOf[user] -= amount;\n        emit Transfer(user, address(0), amount);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/Domain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on code and smartness by Ross Campbell and Keno\n// Uses immutable to store the domain separator to reduce gas usage\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\npragma solidity ^0.8.0;\n\n// solhint-disable no-inline-assembly\n\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\n    }\n\n    constructor() {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n    }\n}\n"
    },
    "contracts/tokens/mocks/LzEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\nimport 'tapioca-sdk/dist/contracts/interfaces/ILayerZeroEndpoint.sol';\r\nimport 'tapioca-sdk/dist/contracts/interfaces/ILayerZeroReceiver.sol';\r\nimport 'tapioca-sdk/dist/contracts/libraries/LzLib.sol';\r\n\r\n/*\r\nlike a real LayerZero endpoint but can be mocked, which handle message transmission, verification, and receipt.\r\n- blocking: LayerZero provides ordered delivery of messages from a given sender to a destination chain.\r\n- non-reentrancy: endpoint has a non-reentrancy guard for both the send() and receive(), respectively.\r\n- adapter parameters: allows UAs to add arbitrary transaction params in the send() function, like airdrop on destination chain.\r\nunlike a real LayerZero endpoint, it is\r\n- no messaging library versioning\r\n- send() will short circuit to lzReceive()\r\n- no user application configuration\r\n*/\r\ncontract LZEndpointMock is ILayerZeroEndpoint {\r\n    uint8 internal constant _NOT_ENTERED = 1;\r\n    uint8 internal constant _ENTERED = 2;\r\n\r\n    mapping(address => address) public lzEndpointLookup;\r\n\r\n    uint16 public mockChainId;\r\n    bool public nextMsgBlocked;\r\n\r\n    // fee config\r\n    RelayerFeeConfig public relayerFeeConfig;\r\n    ProtocolFeeConfig public protocolFeeConfig;\r\n    uint256 public oracleFee;\r\n    bytes public defaultAdapterParams;\r\n\r\n    // path = remote addrss + local address\r\n    // inboundNonce = [srcChainId][path].\r\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\r\n    //todo: this is a hack\r\n    // outboundNonce = [dstChainId][srcAddress]\r\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\r\n    //    // outboundNonce = [dstChainId][path].\r\n    //    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\r\n    // storedPayload = [srcChainId][path]\r\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\r\n    // msgToDeliver = [srcChainId][path]\r\n    mapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\r\n\r\n    // reentrancy guard\r\n    uint8 internal _send_entered_state = 1;\r\n    uint8 internal _receive_entered_state = 1;\r\n\r\n    struct ProtocolFeeConfig {\r\n        uint256 zroFee;\r\n        uint256 nativeBP;\r\n    }\r\n\r\n    struct RelayerFeeConfig {\r\n        uint128 dstPriceRatio; // 10^10\r\n        uint128 dstGasPriceInWei;\r\n        uint128 dstNativeAmtCap;\r\n        uint64 baseGas;\r\n        uint64 gasPerByte;\r\n    }\r\n\r\n    struct StoredPayload {\r\n        uint64 payloadLength;\r\n        address dstAddress;\r\n        bytes32 payloadHash;\r\n    }\r\n\r\n    struct QueuedPayload {\r\n        address dstAddress;\r\n        uint64 nonce;\r\n        bytes payload;\r\n    }\r\n\r\n    modifier sendNonReentrant() {\r\n        require(_send_entered_state == _NOT_ENTERED, 'LayerZeroMock: no send reentrancy');\r\n        _send_entered_state = _ENTERED;\r\n        _;\r\n        _send_entered_state = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier receiveNonReentrant() {\r\n        require(_receive_entered_state == _NOT_ENTERED, 'LayerZeroMock: no receive reentrancy');\r\n        _receive_entered_state = _ENTERED;\r\n        _;\r\n        _receive_entered_state = _NOT_ENTERED;\r\n    }\r\n\r\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\r\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\r\n    event PayloadStored(uint16 srcChainId, bytes srcAddress, address dstAddress, uint64 nonce, bytes payload, bytes reason);\r\n    event ValueTransferFailed(address indexed to, uint256 indexed quantity);\r\n\r\n    constructor(uint16 _chainId) {\r\n        mockChainId = _chainId;\r\n\r\n        // init config\r\n        relayerFeeConfig = RelayerFeeConfig({\r\n            dstPriceRatio: 1e10, // 1:1, same chain, same native coin\r\n            dstGasPriceInWei: 1e10,\r\n            dstNativeAmtCap: 1e19,\r\n            baseGas: 100,\r\n            gasPerByte: 1\r\n        });\r\n        protocolFeeConfig = ProtocolFeeConfig({zroFee: 1e18, nativeBP: 1000}); // BP 0.1\r\n        oracleFee = 1e16;\r\n        defaultAdapterParams = LzLib.buildDefaultAdapterParams(200000);\r\n    }\r\n\r\n    // ------------------------------ ILayerZeroEndpoint Functions ------------------------------\r\n    function send(\r\n        uint16 _chainId,\r\n        bytes memory _path,\r\n        bytes calldata _payload,\r\n        address payable _refundAddress,\r\n        address _zroPaymentAddress,\r\n        bytes memory _adapterParams\r\n    ) external payable override sendNonReentrant {\r\n        // require(_path.length == 40, 'LayerZeroMock: incorrect remote address size'); // only support evm chains\r\n\r\n        address dstAddr;\r\n        assembly {\r\n            dstAddr := mload(add(_path, 20))\r\n        }\r\n\r\n        address lzEndpoint = lzEndpointLookup[dstAddr];\r\n        require(lzEndpoint != address(0), 'LayerZeroMock: destination LayerZero Endpoint not found');\r\n\r\n        // not handle zro token\r\n        bytes memory adapterParams = _adapterParams.length > 0 ? _adapterParams : defaultAdapterParams;\r\n        (uint256 nativeFee, ) = estimateFees(_chainId, msg.sender, _payload, _zroPaymentAddress != address(0x0), adapterParams);\r\n        require(msg.value >= nativeFee, 'LayerZeroMock: not enough native for fees');\r\n\r\n        uint64 nonce = ++outboundNonce[_chainId][msg.sender];\r\n\r\n        // refund if they send too much\r\n        uint256 amount = msg.value - nativeFee;\r\n        if (amount > 0) {\r\n            (bool success, ) = _refundAddress.call{value: amount}('');\r\n            require(success, 'LayerZeroMock: failed to refund');\r\n        }\r\n\r\n        // Mock the process of receiving msg on dst chain\r\n        // Mock the relayer paying the dstNativeAddr the amount of extra native token\r\n        (, uint256 extraGas, uint256 dstNativeAmt, address payable dstNativeAddr) = LzLib.decodeAdapterParams(adapterParams);\r\n        if (dstNativeAmt > 0) {\r\n            (bool success, ) = dstNativeAddr.call{value: dstNativeAmt}('');\r\n            if (!success) {\r\n                emit ValueTransferFailed(dstNativeAddr, dstNativeAmt);\r\n            }\r\n        }\r\n\r\n        bytes memory srcUaAddress = abi.encodePacked(msg.sender, dstAddr); // cast this address to bytes\r\n        bytes memory payload = _payload;\r\n        LZEndpointMock(lzEndpoint).receivePayload(mockChainId, srcUaAddress, dstAddr, nonce, extraGas, payload);\r\n    }\r\n\r\n    function receivePayload(\r\n        uint16 _srcChainId,\r\n        bytes calldata _path,\r\n        address _dstAddress,\r\n        uint64 _nonce,\r\n        uint256 _gasLimit,\r\n        bytes calldata _payload\r\n    ) external override receiveNonReentrant {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\r\n\r\n        // assert and increment the nonce. no message shuffling\r\n        require(_nonce == ++inboundNonce[_srcChainId][_path], 'LayerZeroMock: wrong nonce');\r\n\r\n        // queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\r\n        if (sp.payloadHash != bytes32(0)) {\r\n            QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_path];\r\n            QueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\r\n\r\n            // warning, might run into gas issues trying to forward through a bunch of queued msgs\r\n            // shift all the msgs over so we can treat this like a fifo via array.pop()\r\n            if (msgs.length > 0) {\r\n                // extend the array\r\n                msgs.push(newMsg);\r\n\r\n                // shift all the indexes up for pop()\r\n                for (uint256 i = 0; i < msgs.length - 1; i++) {\r\n                    msgs[i + 1] = msgs[i];\r\n                }\r\n\r\n                // put the newMsg at the bottom of the stack\r\n                msgs[0] = newMsg;\r\n            } else {\r\n                msgs.push(newMsg);\r\n            }\r\n        } else if (nextMsgBlocked) {\r\n            storedPayload[_srcChainId][_path] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\r\n            emit PayloadStored(_srcChainId, _path, _dstAddress, _nonce, _payload, bytes(''));\r\n            // ensure the next msgs that go through are no longer blocked\r\n            nextMsgBlocked = false;\r\n        } else {\r\n            try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _path, _nonce, _payload) {} catch (\r\n                bytes memory reason\r\n            ) {\r\n                storedPayload[_srcChainId][_path] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\r\n                emit PayloadStored(_srcChainId, _path, _dstAddress, _nonce, _payload, reason);\r\n                // ensure the next msgs that go through are no longer blocked\r\n                nextMsgBlocked = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getInboundNonce(uint16 _chainID, bytes calldata _path) external view override returns (uint64) {\r\n        return inboundNonce[_chainID][_path];\r\n    }\r\n\r\n    function getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\r\n        return outboundNonce[_chainID][_srcAddress];\r\n    }\r\n\r\n    function estimateFees(\r\n        uint16 _dstChainId,\r\n        address _userApplication,\r\n        bytes memory _payload,\r\n        bool _payInZRO,\r\n        bytes memory _adapterParams\r\n    ) public view returns (uint256 nativeFee, uint256 zroFee) {\r\n        bytes memory adapterParams = _adapterParams.length > 0 ? _adapterParams : defaultAdapterParams;\r\n\r\n        // Relayer Fee\r\n        uint256 relayerFee = _getRelayerFee(_dstChainId, 1, _userApplication, _payload.length, adapterParams);\r\n\r\n        // LayerZero Fee\r\n        uint256 protocolFee = _getProtocolFees(_payInZRO, relayerFee, oracleFee);\r\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\r\n\r\n        // return the sum of fees\r\n        nativeFee = nativeFee + relayerFee + oracleFee;\r\n    }\r\n\r\n    function getChainId() external view override returns (uint16) {\r\n        return mockChainId;\r\n    }\r\n\r\n    function retryPayload(\r\n        uint16 _srcChainId,\r\n        bytes calldata _path,\r\n        bytes calldata _payload\r\n    ) external override {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\r\n        require(sp.payloadHash != bytes32(0), 'LayerZeroMock: no stored payload');\r\n        require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, 'LayerZeroMock: invalid payload');\r\n\r\n        address dstAddress = sp.dstAddress;\r\n        // empty the storedPayload\r\n        sp.payloadLength = 0;\r\n        sp.dstAddress = address(0);\r\n        sp.payloadHash = bytes32(0);\r\n\r\n        uint64 nonce = inboundNonce[_srcChainId][_path];\r\n\r\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _path, nonce, _payload);\r\n        emit PayloadCleared(_srcChainId, _path, nonce, dstAddress);\r\n    }\r\n\r\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _path) external view override returns (bool) {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\r\n        return sp.payloadHash != bytes32(0);\r\n    }\r\n\r\n    function getSendLibraryAddress(address) external view override returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    function getReceiveLibraryAddress(address) external view override returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    function isSendingPayload() external view override returns (bool) {\r\n        return _send_entered_state == _ENTERED;\r\n    }\r\n\r\n    function isReceivingPayload() external view override returns (bool) {\r\n        return _receive_entered_state == _ENTERED;\r\n    }\r\n\r\n    function getConfig(\r\n        uint16, /*_version*/\r\n        uint16, /*_chainId*/\r\n        address, /*_ua*/\r\n        uint256 /*_configType*/\r\n    ) external pure override returns (bytes memory) {\r\n        return '';\r\n    }\r\n\r\n    function getSendVersion(\r\n        address /*_userApplication*/\r\n    ) external pure override returns (uint16) {\r\n        return 1;\r\n    }\r\n\r\n    function getReceiveVersion(\r\n        address /*_userApplication*/\r\n    ) external pure override returns (uint16) {\r\n        return 1;\r\n    }\r\n\r\n    function setConfig(\r\n        uint16, /*_version*/\r\n        uint16, /*_chainId*/\r\n        uint256, /*_configType*/\r\n        bytes memory /*_config*/\r\n    ) external override {}\r\n\r\n    function setSendVersion(\r\n        uint16 /*version*/\r\n    ) external override {}\r\n\r\n    function setReceiveVersion(\r\n        uint16 /*version*/\r\n    ) external override {}\r\n\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _path) external override {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\r\n        // revert if no messages are cached. safeguard malicious UA behaviour\r\n        require(sp.payloadHash != bytes32(0), 'LayerZeroMock: no stored payload');\r\n        require(sp.dstAddress == msg.sender, 'LayerZeroMock: invalid caller');\r\n\r\n        // empty the storedPayload\r\n        sp.payloadLength = 0;\r\n        sp.dstAddress = address(0);\r\n        sp.payloadHash = bytes32(0);\r\n\r\n        emit UaForceResumeReceive(_srcChainId, _path);\r\n\r\n        // resume the receiving of msgs after we force clear the \"stuck\" msg\r\n        _clearMsgQue(_srcChainId, _path);\r\n    }\r\n\r\n    // ------------------------------ Other Public/External Functions --------------------------------------------------\r\n\r\n    function getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint256) {\r\n        return msgsToDeliver[_srcChainId][_srcAddress].length;\r\n    }\r\n\r\n    // used to simulate messages received get stored as a payload\r\n    function blockNextMsg() external {\r\n        nextMsgBlocked = true;\r\n    }\r\n\r\n    function setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\r\n        lzEndpointLookup[destAddr] = lzEndpointAddr;\r\n    }\r\n\r\n    function setRelayerPrice(\r\n        uint128 _dstPriceRatio,\r\n        uint128 _dstGasPriceInWei,\r\n        uint128 _dstNativeAmtCap,\r\n        uint64 _baseGas,\r\n        uint64 _gasPerByte\r\n    ) external {\r\n        relayerFeeConfig.dstPriceRatio = _dstPriceRatio;\r\n        relayerFeeConfig.dstGasPriceInWei = _dstGasPriceInWei;\r\n        relayerFeeConfig.dstNativeAmtCap = _dstNativeAmtCap;\r\n        relayerFeeConfig.baseGas = _baseGas;\r\n        relayerFeeConfig.gasPerByte = _gasPerByte;\r\n    }\r\n\r\n    function setProtocolFee(uint256 _zroFee, uint256 _nativeBP) external {\r\n        protocolFeeConfig.zroFee = _zroFee;\r\n        protocolFeeConfig.nativeBP = _nativeBP;\r\n    }\r\n\r\n    function setOracleFee(uint256 _oracleFee) external {\r\n        oracleFee = _oracleFee;\r\n    }\r\n\r\n    function setDefaultAdapterParams(bytes memory _adapterParams) external {\r\n        defaultAdapterParams = _adapterParams;\r\n    }\r\n\r\n    // --------------------- Internal Functions ---------------------\r\n    // simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\r\n    function _clearMsgQue(uint16 _srcChainId, bytes calldata _path) internal {\r\n        QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_path];\r\n\r\n        // warning, might run into gas issues trying to forward through a bunch of queued msgs\r\n        while (msgs.length > 0) {\r\n            QueuedPayload memory payload = msgs[msgs.length - 1];\r\n            ILayerZeroReceiver(payload.dstAddress).lzReceive(_srcChainId, _path, payload.nonce, payload.payload);\r\n            msgs.pop();\r\n        }\r\n    }\r\n\r\n    function _getProtocolFees(\r\n        bool _payInZro,\r\n        uint256 _relayerFee,\r\n        uint256 _oracleFee\r\n    ) internal view returns (uint256) {\r\n        if (_payInZro) {\r\n            return protocolFeeConfig.zroFee;\r\n        } else {\r\n            return ((_relayerFee + _oracleFee) * protocolFeeConfig.nativeBP) / 10000;\r\n        }\r\n    }\r\n\r\n    function _getRelayerFee(\r\n        uint16, /* _dstChainId */\r\n        uint16, /* _outboundProofType */\r\n        address, /* _userApplication */\r\n        uint256 _payloadSize,\r\n        bytes memory _adapterParams\r\n    ) internal view returns (uint256) {\r\n        (uint16 txType, uint256 extraGas, uint256 dstNativeAmt, ) = LzLib.decodeAdapterParams(_adapterParams);\r\n        uint256 totalRemoteToken; // = baseGas + extraGas + requiredNativeAmount\r\n        if (txType == 2) {\r\n            require(relayerFeeConfig.dstNativeAmtCap >= dstNativeAmt, 'LayerZeroMock: dstNativeAmt too large ');\r\n            totalRemoteToken += dstNativeAmt;\r\n        }\r\n        // remoteGasTotal = dstGasPriceInWei * (baseGas + extraGas)\r\n        uint256 remoteGasTotal = relayerFeeConfig.dstGasPriceInWei * (relayerFeeConfig.baseGas + extraGas);\r\n        totalRemoteToken += remoteGasTotal;\r\n\r\n        // tokenConversionRate = dstPrice / localPrice\r\n        // basePrice = totalRemoteToken * tokenConversionRate\r\n        uint256 basePrice = (totalRemoteToken * relayerFeeConfig.dstPriceRatio) / 10**10;\r\n\r\n        // pricePerByte = (dstGasPriceInWei * gasPerBytes) * tokenConversionRate\r\n        uint256 pricePerByte = (relayerFeeConfig.dstGasPriceInWei * relayerFeeConfig.gasPerByte * relayerFeeConfig.dstPriceRatio) / 10**10;\r\n\r\n        return basePrice + _payloadSize * pricePerByte;\r\n    }\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ILayerZeroReceiver {\r\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\r\n    // @param _srcChainId - the source endpoint identifier\r\n    // @param _srcAddress - the source sending contract address from the source chain\r\n    // @param _nonce - the ordered message nonce\r\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\r\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/libraries/LzLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity >=0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary LzLib {\r\n    // LayerZero communication\r\n    struct CallParams {\r\n        address payable refundAddress;\r\n        address zroPaymentAddress;\r\n    }\r\n\r\n    //---------------------------------------------------------------------------\r\n    // Address type handling\r\n\r\n    struct AirdropParams {\r\n        uint airdropAmount;\r\n        bytes32 airdropAddress;\r\n    }\r\n\r\n    function buildAdapterParams(LzLib.AirdropParams memory _airdropParams, uint _uaGasLimit) internal pure returns (bytes memory adapterParams) {\r\n        if (_airdropParams.airdropAmount == 0 && _airdropParams.airdropAddress == bytes32(0x0)) {\r\n            adapterParams = buildDefaultAdapterParams(_uaGasLimit);\r\n        } else {\r\n            adapterParams = buildAirdropAdapterParams(_uaGasLimit, _airdropParams);\r\n        }\r\n    }\r\n\r\n    // Build Adapter Params\r\n    function buildDefaultAdapterParams(uint _uaGas) internal pure returns (bytes memory) {\r\n        // txType 1\r\n        // bytes  [2       32      ]\r\n        // fields [txType  extraGas]\r\n        return abi.encodePacked(uint16(1), _uaGas);\r\n    }\r\n\r\n    function buildAirdropAdapterParams(uint _uaGas, AirdropParams memory _params) internal pure returns (bytes memory) {\r\n        require(_params.airdropAmount > 0, \"Airdrop amount must be greater than 0\");\r\n        require(_params.airdropAddress != bytes32(0x0), \"Airdrop address must be set\");\r\n\r\n        // txType 2\r\n        // bytes  [2       32        32            bytes[]         ]\r\n        // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\r\n        return abi.encodePacked(uint16(2), _uaGas, _params.airdropAmount, _params.airdropAddress);\r\n    }\r\n\r\n    function getGasLimit(bytes memory _adapterParams) internal pure returns (uint gasLimit) {\r\n        require(_adapterParams.length == 34 || _adapterParams.length > 66, \"Invalid adapterParams\");\r\n        assembly {\r\n            gasLimit := mload(add(_adapterParams, 34))\r\n        }\r\n    }\r\n\r\n    // Decode Adapter Params\r\n    function decodeAdapterParams(bytes memory _adapterParams) internal pure returns (uint16 txType, uint uaGas, uint airdropAmount, address payable airdropAddress) {\r\n        require(_adapterParams.length == 34 || _adapterParams.length > 66, \"Invalid adapterParams\");\r\n        assembly {\r\n            txType := mload(add(_adapterParams, 2))\r\n            uaGas := mload(add(_adapterParams, 34))\r\n        }\r\n        require(txType == 1 || txType == 2, \"Unsupported txType\");\r\n        require(uaGas > 0, \"Gas too low\");\r\n\r\n        if (txType == 2) {\r\n            assembly {\r\n                airdropAmount := mload(add(_adapterParams, 66))\r\n                airdropAddress := mload(add(_adapterParams, 86))\r\n            }\r\n        }\r\n    }\r\n\r\n    //---------------------------------------------------------------------------\r\n    // Address type handling\r\n    // TODO: testing\r\n    function bytes32ToAddress(bytes32 _bytes32Address) internal pure returns (address _address) {\r\n        require(bytes12(_bytes32Address) == bytes12(0), \"Invalid address\"); // first 12 bytes should be empty\r\n        return address(uint160(uint(_bytes32Address)));\r\n    }\r\n\r\n    function addressToBytes32(address _address) internal pure returns (bytes32 _bytes32Address) {\r\n        return bytes32(uint(uint160(_address)));\r\n    }\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\nimport \"./ILayerZeroUserApplicationConfig.sol\";\r\n\r\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\r\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\r\n    // @param _payload - a custom bytes payload to send to the destination contract\r\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\r\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\r\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\r\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    // @notice used by the messaging library to publish verified payload\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source contract (as bytes) at the source chain\r\n    // @param _dstAddress - the address on destination chain\r\n    // @param _nonce - the unbound message ordering nonce\r\n    // @param _gasLimit - the gas limit for external contract execution\r\n    // @param _payload - verified payload to send to the destination contract\r\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\r\n\r\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\r\n\r\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\r\n    // @param _srcAddress - the source chain contract address\r\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\r\n\r\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    // @param _payload - the custom message to send over LayerZero\r\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\r\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    // @notice get this Endpoint's immutable source identifier\r\n    function getChainId() external view returns (uint16);\r\n\r\n    // @notice the interface to retry failed message on this Endpoint destination\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    // @param _payload - the payload to be retried\r\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\r\n\r\n    // @notice query if any STORED payload (message blocking) at the endpoint.\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\r\n\r\n    // @notice query if the _libraryAddress is valid for sending msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the _libraryAddress is valid for receiving msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the non-reentrancy guard for send() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isSendingPayload() external view returns (bool);\r\n\r\n    // @notice query if the non-reentrancy guard for receive() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isReceivingPayload() external view returns (bool);\r\n\r\n    // @notice get the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _userApplication - the contract address of the user application\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\r\n\r\n    // @notice get the send() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getSendVersion(address _userApplication) external view returns (uint16);\r\n\r\n    // @notice get the lzReceive() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ILayerZeroUserApplicationConfig {\r\n    // @notice set the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    // @param _config - configuration in the bytes. can encode arbitrary content.\r\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\r\n\r\n    // @notice set the send() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setSendVersion(uint16 _version) external;\r\n\r\n    // @notice set the lzReceive() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setReceiveVersion(uint16 _version) external;\r\n\r\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\r\n    // @param _srcChainId - the chainId of the source chain\r\n    // @param _srcAddress - the contract address of the source contract at the source chain\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/lzApp/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/ILayerZeroReceiver.sol\";\r\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\r\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\r\nimport \"../util/BytesLib.sol\";\r\n\r\n/*\r\n * a generic LzReceiver implementation\r\n */\r\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\r\n    using BytesLib for bytes;\r\n\r\n    ILayerZeroEndpoint public immutable lzEndpoint;\r\n    mapping(uint16 => bytes) public trustedRemoteLookup;\r\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\r\n    address public precrime;\r\n\r\n    event SetPrecrime(address precrime);\r\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\r\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\r\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\r\n\r\n    constructor(address _endpoint) {\r\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\r\n    }\r\n\r\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\r\n        // lzReceive must be called by the endpoint for security\r\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\r\n\r\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\r\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\r\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\r\n\r\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n\r\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\r\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\r\n\r\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\r\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\r\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\r\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n    }\r\n\r\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\r\n        uint providedGasLimit = _getGasLimit(_adapterParams);\r\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\r\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\r\n        require(providedGasLimit >= minGasLimit, \"LzApp: gas limit is too low\");\r\n    }\r\n\r\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\r\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\r\n        assembly {\r\n            gasLimit := mload(add(_adapterParams, 34))\r\n        }\r\n    }\r\n\r\n    //---------------------------UserApplication config----------------------------------------\r\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\r\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\r\n    }\r\n\r\n    // generic config for LayerZero user Application\r\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\r\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\r\n    }\r\n\r\n    function setSendVersion(uint16 _version) external override onlyOwner {\r\n        lzEndpoint.setSendVersion(_version);\r\n    }\r\n\r\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\r\n        lzEndpoint.setReceiveVersion(_version);\r\n    }\r\n\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\r\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\r\n    }\r\n\r\n    // _path = abi.encodePacked(remoteAddress, localAddress)\r\n    // this function set the trusted path for the cross-chain communication\r\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external onlyOwner {\r\n        trustedRemoteLookup[_srcChainId] = _path;\r\n        emit SetTrustedRemote(_srcChainId, _path);\r\n    }\r\n\r\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\r\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\r\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\r\n    }\r\n\r\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\r\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\r\n        require(path.length != 0, \"LzApp: no trusted path record\");\r\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\r\n    }\r\n\r\n    function setPrecrime(address _precrime) external onlyOwner {\r\n        precrime = _precrime;\r\n        emit SetPrecrime(_precrime);\r\n    }\r\n\r\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\r\n        require(_minGas > 0, \"LzApp: invalid minGas\");\r\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\r\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\r\n    }\r\n\r\n    //--------------------------- VIEW FUNCTION ----------------------------------------\r\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\r\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\r\n        return keccak256(trustedSource) == keccak256(_srcAddress);\r\n    }\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/util/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n        // Get a location of some free memory and store it in tempBytes as\r\n        // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n        // Store the length of the first bytes array at the beginning of\r\n        // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n        // Maintain a memory counter for the current write location in the\r\n        // temp bytes array by adding the 32 bytes for the array length to\r\n        // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n        // Stop copying when the memory counter reaches the length of the\r\n        // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n            // Initialize a copy counter to the start of the _preBytes data,\r\n            // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n            // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n            // Write the _preBytes data into the tempBytes memory 32 bytes\r\n            // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n        // Add the length of _postBytes to the current length of tempBytes\r\n        // and store it as the new length in the first 32 bytes of the\r\n        // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n        // Move the memory counter back from a multiple of 0x20 to the\r\n        // actual end of the _preBytes data.\r\n            mc := end\r\n        // Stop copying when the memory counter reaches the new combined\r\n        // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n        // Update the free-memory pointer by padding our last write location\r\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n        // next 32 byte block, then round down to the nearest multiple of\r\n        // 32. If the sum of the length of the two arrays is zero then add\r\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n            not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n        // Read the first 32 bytes of _preBytes storage, which is the length\r\n        // of the array. (We don't need to use the offset into the slot\r\n        // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes.slot)\r\n        // Arrays of 31 bytes or less have an even value in their slot,\r\n        // while longer arrays have an odd value. The actual length is\r\n        // the slot divided by two for odd values, and the lowest order\r\n        // byte divided by two for even values.\r\n        // If the slot is even, bitwise and the slot with 255 and divide by\r\n        // two to get the length. If the slot is odd, bitwise and the slot\r\n        // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n        // slength can contain both the length and contents of the array\r\n        // if length < 32 bytes so let's prepare for that\r\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n            // Since the new array still fits in the slot, we just need to\r\n            // update the contents of the slot.\r\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                _preBytes.slot,\r\n                // all the modifications to the slot are inside this\r\n                // next block\r\n                add(\r\n                // we can just add to the slot contents because the\r\n                // bytes we want to change are the LSBs\r\n                fslot,\r\n                add(\r\n                mul(\r\n                div(\r\n                // load the bytes from memory\r\n                mload(add(_postBytes, 0x20)),\r\n                // zero all bytes to the right\r\n                exp(0x100, sub(32, mlength))\r\n                ),\r\n                // and now shift left the number of bytes to\r\n                // leave space for the length in the slot\r\n                exp(0x100, sub(32, newlength))\r\n                ),\r\n                // increase length by the double of the memory\r\n                // bytes length\r\n                mul(mlength, 2)\r\n                )\r\n                )\r\n                )\r\n            }\r\n            case 1 {\r\n            // The stored value fits in the slot, but the combined value\r\n            // will exceed it.\r\n            // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n            // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n            // The contents of the _postBytes array start 32 bytes into\r\n            // the structure. Our first read should obtain the `submod`\r\n            // bytes that can fit into the unused space in the last word\r\n            // of the stored array. To get this, we read 32 bytes starting\r\n            // from `submod`, so the data we read overlaps with the array\r\n            // contents by `submod` bytes. Masking the lowest-order\r\n            // `submod` bytes allows us to add that value directly to the\r\n            // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                sc,\r\n                add(\r\n                and(\r\n                fslot,\r\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                ),\r\n                and(mload(mc), mask)\r\n                )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n            // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes.slot)\r\n            // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n            // save new length\r\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\r\n\r\n            // Copy over the first `submod` bytes of the new data as in\r\n            // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n            // The first word of the slice result is potentially a partial\r\n            // word read from the original array. To read it, we calculate\r\n            // the length of that partial word and start copying that many\r\n            // bytes into the array. The first word we copy will start with\r\n            // data we don't care about, but the last `lengthmod` bytes will\r\n            // land at the beginning of the contents of the new array. When\r\n            // we're done copying, we overwrite the full first word with\r\n            // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n            // The multiplication in the next line is necessary\r\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n            // the following copy loop was copying the origin's length\r\n            // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                // The multiplication in the next line has the same exact purpose\r\n                // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n            //update free-memory pointer\r\n            //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n            //zero out the 32 bytes slice we are about to return\r\n            //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\r\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\r\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\r\n        uint16 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x2), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\r\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\r\n        uint32 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x4), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\r\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\r\n        uint64 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x8), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\r\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\r\n        uint96 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0xc), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\r\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\r\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\r\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n        // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n            // cb is a circuit breaker in the for loop since there's\r\n            //  no said feature for inline assembly loops\r\n            // cb = 1 - don't breaker\r\n            // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint256(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                    // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n            // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(\r\n        bytes storage _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        bool success = true;\r\n\r\n        assembly {\r\n        // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes.slot)\r\n        // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n        // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                    // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                        // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                    // cb is a circuit breaker in the for loop since there's\r\n                    //  no said feature for inline assembly loops\r\n                    // cb = 1 - don't breaker\r\n                    // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                    // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes.slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                    // the next line is the loop condition:\r\n                    // while(uint256(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                            // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n            // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "tapioca-sdk/dist/contracts/token/oft/IOFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface IOFTCore is IERC165 {\r\n    /**\r\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\r\n     * _dstChainId - L0 defined chain id to send tokens too\r\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n     * _amount - amount of the tokens to transfer\r\n     * _useZro - indicates to use zro to pay L0 fees\r\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\r\n     */\r\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    /**\r\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\r\n     * `_from` the owner of token\r\n     * `_dstChainId` the destination chain identifier\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_amount` the quantity of tokens in wei\r\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    /**\r\n     * @dev returns the circulating amount of tokens on current chain\r\n     */\r\n    function circulatingSupply() external view returns (uint);\r\n\r\n    /**\r\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\r\n     * `_nonce` is the outbound nonce\r\n     */\r\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint _amount);\r\n\r\n    /**\r\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\r\n     * `_nonce` is the inbound nonce.\r\n     */\r\n    event ReceiveFromChain(uint16 indexed _srcChainId, bytes _fromAddress, address indexed _to, uint _amount);\r\n\r\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "tapioca-sdk/dist/contracts/token/oft/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../lzApp/NonblockingLzApp.sol\";\r\nimport \"./IOFTCore.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\nabstract contract OFTCore is NonblockingLzApp, ERC165, IOFTCore {\r\n    using BytesLib for bytes;\r\n\r\n    uint public constant NO_EXTRA_GAS = 0;\r\n\r\n    // packet type\r\n    uint16 public constant PT_SEND = 0;\r\n\r\n    bool public useCustomAdapterParams;\r\n\r\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\r\n        // mock the payload for sendFrom()\r\n        bytes memory payload = abi.encode(PT_SEND, abi.encodePacked(msg.sender), _toAddress, _amount);\r\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\r\n    }\r\n\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\r\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n    }\r\n\r\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\r\n        useCustomAdapterParams = _useCustomAdapterParams;\r\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\r\n    }\r\n\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        uint16 packetType;\r\n        assembly {\r\n            packetType := mload(add(_payload, 32))\r\n        }\r\n\r\n        if (packetType == PT_SEND) {\r\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\r\n        } else {\r\n            revert(\"OFTCore: unknown packet type\");\r\n        }\r\n    }\r\n\r\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\r\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\r\n\r\n        _debitFrom(_from, _dstChainId, _toAddress, _amount);\r\n\r\n        bytes memory lzPayload = abi.encode(PT_SEND, abi.encodePacked(_from), _toAddress, _amount);\r\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\r\n\r\n        emit SendToChain(_dstChainId, _from, _toAddress, _amount);\r\n    }\r\n\r\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\r\n        (, bytes memory from, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, bytes, uint));\r\n\r\n        address to = toAddressBytes.toAddress(0);\r\n\r\n        _creditTo(_srcChainId, to, amount);\r\n        emit ReceiveFromChain(_srcChainId, from, to, amount);\r\n    }\r\n\r\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\r\n        if (useCustomAdapterParams) {\r\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\r\n        } else {\r\n            require(_adapterParams.length == 0, \"OFTCore: _adapterParams must be empty.\");\r\n        }\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual;\r\n\r\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual;\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/lzApp/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./LzApp.sol\";\r\nimport \"../util/ExcessivelySafeCall.sol\";\r\n\r\n/*\r\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\r\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\r\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\r\n */\r\nabstract contract NonblockingLzApp is LzApp {\r\n    using ExcessivelySafeCall for address;\r\n\r\n    constructor(address _endpoint) LzApp(_endpoint) {}\r\n\r\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\r\n\r\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\r\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\r\n\r\n    // overriding the virtual function in LzReceiver\r\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\r\n        // try-catch all errors/exceptions\r\n        if (!success) {\r\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\r\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\r\n        }\r\n    }\r\n\r\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\r\n        // only internal transaction\r\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\r\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n\r\n    //@notice override this function\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\r\n\r\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\r\n        // assert there is message to retry\r\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\r\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\r\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\r\n        // clear the stored message\r\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\r\n        // execute the message. revert if it fails again\r\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\r\n    }\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/util/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\r\npragma solidity >=0.7.6;\r\n\r\nlibrary ExcessivelySafeCall {\r\n    uint256 constant LOW_28_MASK =\r\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /// @notice Use when you _really_ really _really_ don't trust the called\r\n    /// contract. This prevents the called contract from causing reversion of\r\n    /// the caller in as many ways as we can.\r\n    /// @dev The main difference between this and a solidity low-level call is\r\n    /// that we limit the number of bytes that the callee can cause to be\r\n    /// copied to caller memory. This prevents stupid things like malicious\r\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\r\n    /// to memory.\r\n    /// @param _target The address to call\r\n    /// @param _gas The amount of gas to forward to the remote contract\r\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\r\n    /// to memory.\r\n    /// @param _calldata The data to send to the remote contract\r\n    /// @return success and returndata, as `.call()`. Returndata is capped to\r\n    /// `_maxCopy` bytes.\r\n    function excessivelySafeCall(\r\n        address _target,\r\n        uint256 _gas,\r\n        uint16 _maxCopy,\r\n        bytes memory _calldata\r\n    ) internal returns (bool, bytes memory) {\r\n        // set up for assembly call\r\n        uint256 _toCopy;\r\n        bool _success;\r\n        bytes memory _returnData = new bytes(_maxCopy);\r\n        // dispatch message to recipient\r\n        // by assembly calling \"handle\" function\r\n        // we call via assembly to avoid memcopying a very large returndata\r\n        // returned by a malicious contract\r\n        assembly {\r\n            _success := call(\r\n            _gas, // gas\r\n            _target, // recipient\r\n            0, // ether value\r\n            add(_calldata, 0x20), // inloc\r\n            mload(_calldata), // inlen\r\n            0, // outloc\r\n            0 // outlen\r\n            )\r\n        // limit our copy to 256 bytes\r\n            _toCopy := returndatasize()\r\n            if gt(_toCopy, _maxCopy) {\r\n                _toCopy := _maxCopy\r\n            }\r\n        // Store the length of the copied bytes\r\n            mstore(_returnData, _toCopy)\r\n        // copy the bytes from returndata[0:_toCopy]\r\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\r\n        }\r\n        return (_success, _returnData);\r\n    }\r\n\r\n    /// @notice Use when you _really_ really _really_ don't trust the called\r\n    /// contract. This prevents the called contract from causing reversion of\r\n    /// the caller in as many ways as we can.\r\n    /// @dev The main difference between this and a solidity low-level call is\r\n    /// that we limit the number of bytes that the callee can cause to be\r\n    /// copied to caller memory. This prevents stupid things like malicious\r\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\r\n    /// to memory.\r\n    /// @param _target The address to call\r\n    /// @param _gas The amount of gas to forward to the remote contract\r\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\r\n    /// to memory.\r\n    /// @param _calldata The data to send to the remote contract\r\n    /// @return success and returndata, as `.call()`. Returndata is capped to\r\n    /// `_maxCopy` bytes.\r\n    function excessivelySafeStaticCall(\r\n        address _target,\r\n        uint256 _gas,\r\n        uint16 _maxCopy,\r\n        bytes memory _calldata\r\n    ) internal view returns (bool, bytes memory) {\r\n        // set up for assembly call\r\n        uint256 _toCopy;\r\n        bool _success;\r\n        bytes memory _returnData = new bytes(_maxCopy);\r\n        // dispatch message to recipient\r\n        // by assembly calling \"handle\" function\r\n        // we call via assembly to avoid memcopying a very large returndata\r\n        // returned by a malicious contract\r\n        assembly {\r\n            _success := staticcall(\r\n            _gas, // gas\r\n            _target, // recipient\r\n            add(_calldata, 0x20), // inloc\r\n            mload(_calldata), // inlen\r\n            0, // outloc\r\n            0 // outlen\r\n            )\r\n        // limit our copy to 256 bytes\r\n            _toCopy := returndatasize()\r\n            if gt(_toCopy, _maxCopy) {\r\n                _toCopy := _maxCopy\r\n            }\r\n        // Store the length of the copied bytes\r\n            mstore(_returnData, _toCopy)\r\n        // copy the bytes from returndata[0:_toCopy]\r\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\r\n        }\r\n        return (_success, _returnData);\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps function selectors in encoded contract calls\r\n     * @dev Allows reuse of encoded calldata for functions with identical\r\n     * argument types but different names. It simply swaps out the first 4 bytes\r\n     * for the new selector. This function modifies memory in place, and should\r\n     * only be used with caution.\r\n     * @param _newSelector The new 4-byte selector\r\n     * @param _buf The encoded contract args\r\n     */\r\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\r\n    internal\r\n    pure\r\n    {\r\n        require(_buf.length >= 4);\r\n        uint256 _mask = LOW_28_MASK;\r\n        assembly {\r\n        // load the first word of\r\n            let _word := mload(add(_buf, 0x20))\r\n        // mask out the top 4 bytes\r\n        // /x\r\n            _word := and(_word, _mask)\r\n            _word := or(_newSelector, _word)\r\n            mstore(add(_buf, 0x20), _word)\r\n        }\r\n    }\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/token/oft/OFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"./IOFT.sol\";\r\nimport \"./OFTCore.sol\";\r\n\r\n// override decimal() function is needed\r\ncontract OFT is OFTCore, ERC20, IOFT {\r\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\r\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function circulatingSupply() public view virtual override returns (uint) {\r\n        return totalSupply();\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override {\r\n        address spender = _msgSender();\r\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\r\n        _burn(_from, _amount);\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override {\r\n        _mint(_toAddress, _amount);\r\n    }\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/token/oft/IOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\nimport \"./IOFTCore.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface of the OFT standard\r\n */\r\ninterface IOFT is IOFTCore, IERC20 {\r\n\r\n}\r\n"
    },
    "tapioca-sdk/dist/contracts/token/oft/extension/PausableOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../OFT.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\n// allow OFT to pause all cross-chain transactions\r\ncontract PausableOFT is OFT, Pausable {\r\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}\r\n\r\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual override whenNotPaused {\r\n        super._debitFrom(_from, _dstChainId, _toAddress, _amount);\r\n    }\r\n\r\n    function pauseSendTokens(bool pause) external onlyOwner {\r\n        pause ? _pause() : _unpause();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/tokens/TapOFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport 'tapioca-sdk/dist/contracts/interfaces/ILayerZeroEndpoint.sol';\r\nimport 'tapioca-sdk/dist/contracts/token/oft/extension/PausableOFT.sol';\r\nimport 'tapioca-sdk/dist/contracts/libraries/LzLib.sol';\r\nimport 'prb-math/contracts/PRBMathSD59x18.sol';\r\n\r\n/*\r\n\r\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \r\n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \r\n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \r\n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \r\n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \r\n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \r\n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \r\n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \r\n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\r\n\r\n*/\r\n\r\n/// @title Tapioca OFT token\r\n/// @notice OFT compatible TAP token\r\n/// @dev Latest size: 17.663  KiB\r\n/// @dev Emissions calculator: https://www.desmos.com/calculator/1fa0zen2ut\r\ncontract TapOFT is PausableOFT {\r\n    using ExcessivelySafeCall for address;\r\n    using PRBMathSD59x18 for int256;\r\n    using BytesLib for bytes;\r\n\r\n    // ==========\r\n    // *DATA*\r\n    // ==========\r\n\r\n    //  Allocation:\r\n    // =========\r\n    // * Team: 15m\r\n    // * Advisors: 4m\r\n    // * DAO: 63m\r\n    // * Seed: 8m\r\n    // * OTC: 5m\r\n    // * LBP: 5m\r\n    // == 100M ==\r\n    uint256 public constant INITIAL_SUPPLY = 1e18 * 100_000_000;\r\n    uint256 public constant LOCK = 10;\r\n    uint256 public constant INCREASE_AMOUNT = 11;\r\n\r\n    /// @notice the a parameter used in the emission function; can be changed by governance\r\n    /// @dev formula: b(xe^(c-f(x))) where f(x)=x/a\r\n    int256 public a_param = 24 * 10e17; // 24\r\n\r\n    /// @notice the b parameter used in the emission function; can be changed by governance\r\n    /// @dev formula: b(xe^(c-f(x))) where f(x)=x/a\r\n    int256 public b_param = 2883;\r\n\r\n    /// @notice the c parameter used in the emission function; can be changed by governance\r\n    /// @dev formula: b(xe^(c-f(x))) where f(x)=x/a\r\n    int256 public c_param = 37 * 10e16; // 3.7\r\n\r\n    /// @notice seconds in a week\r\n    uint256 public constant WEEK = 604800;\r\n\r\n    /// @notice starts time for emissions\r\n    /// @dev initialized in the constructor with block.timestamp\r\n    uint256 public immutable emissionsStartTime;\r\n\r\n    /// @notice returns the amount minted for a specific week\r\n    /// @dev week is computed using (timestamp - emissionStartTime) / WEEK\r\n    mapping(int256 => uint256) public mintedInWeek;\r\n\r\n    /// @notice returns the minter address\r\n    address public minter;\r\n\r\n    /// @notice LayerZero governance chain identifier\r\n    uint256 public governanceChainIdentifier;\r\n\r\n    // ==========\r\n    // *EVENTS*\r\n    // ==========\r\n    /// @notice event emitted when a new minter is set\r\n    event MinterUpdated(address indexed _old, address indexed _new);\r\n    /// @notice event emitted when new TAP is minted\r\n    event Minted(address indexed _by, address indexed _to, uint256 _amount);\r\n    /// @notice event emitted when new TAP is burned\r\n    event Burned(address indexed _by, address indexed _from, uint256 _amount);\r\n    /// @notice event emitted when mining parameters are updated\r\n    event UpdateMiningParameters(uint256 _blockTimestmap, uint256 _rate, uint256 _startEpochSupply);\r\n    /// @notice event emitted when the A parameter of the emission formula is updated\r\n    event AParamUpdated(int256 _old, int256 _new);\r\n    /// @notice event emitted when the B parameter of the emission formula is updated\r\n    event BParamUpdated(int256 _old, int256 _new);\r\n    /// @notice event emitted when the C parameter of the emission formula is updated\r\n    event CParamUpdated(int256 _old, int256 _new);\r\n    /// @notice event emitted when the governance chain identifier is updated\r\n    event GovernanceChainIdentifierUpdated(uint256 _old, uint256 _new);\r\n\r\n    // ==========\r\n    // * METHODS *\r\n    // ==========\r\n    /// @notice Creates a new TAP OFT type token\r\n    /// @dev The initial supply of 100M is not minted here as we have the wrap method\r\n    /// @param _lzEndpoint the layer zero address endpoint deployed on the current chain\r\n    /// @param _team address for the team tokens\r\n    /// @param _advisors address for the advisors tokens\r\n    /// @param _dao address for the DAO tokens\r\n    /// @param _seed address for the seed tokens\r\n    /// @param _otc address for the OTC tokens\r\n    /// @param _lbp address for the LBP tokens\r\n    /// @param _governanceChainId Chain id\r\n    constructor(\r\n        address _lzEndpoint,\r\n        address _team,\r\n        address _advisors,\r\n        address _dao,\r\n        address _seed,\r\n        address _otc,\r\n        address _lbp,\r\n        uint256 _governanceChainId\r\n    ) PausableOFT('Tapioca', 'TAP', _lzEndpoint) {\r\n        require(_lzEndpoint != address(0), 'LZ endpoint not valid');\r\n        governanceChainIdentifier = _governanceChainId;\r\n        if (_getChainId() == governanceChainIdentifier) {\r\n            _mint(_team, 1e18 * 15_000_000);\r\n            _mint(_advisors, 1e18 * 4_000_000);\r\n            _mint(_dao, 1e18 * 63_000_000);\r\n            _mint(_seed, 1e18 * 8_000_000);\r\n            _mint(_otc, 1e18 * 5_000_000);\r\n            _mint(_lbp, 1e18 * 5_000_000);\r\n            require(totalSupply() == INITIAL_SUPPLY, 'initial supply not valid');\r\n        }\r\n        emissionsStartTime = block.timestamp;\r\n    }\r\n\r\n    ///-- Owner methods --\r\n    /// @notice sets the governance chain identifier\r\n    /// @param _identifier LayerZero chain identifier\r\n    function setGovernanceChainIdentifier(uint256 _identifier) external onlyOwner {\r\n        emit GovernanceChainIdentifierUpdated(governanceChainIdentifier, _identifier);\r\n        governanceChainIdentifier = _identifier;\r\n    }\r\n\r\n    /// @notice sets a new value for parameter\r\n    /// @param val the new value\r\n    function setAParam(int256 val) external onlyOwner {\r\n        emit AParamUpdated(a_param, val);\r\n        a_param = val;\r\n    }\r\n\r\n    /// @notice sets a new value for parameter\r\n    /// @param val the new value\r\n    function setBParam(int256 val) external onlyOwner {\r\n        emit BParamUpdated(b_param, val);\r\n        b_param = val;\r\n    }\r\n\r\n    /// @notice sets a new value for parameter\r\n    /// @param val the new value\r\n    function setCParam(int256 val) external onlyOwner {\r\n        emit CParamUpdated(c_param, val);\r\n        c_param = val;\r\n    }\r\n\r\n    /// @notice sets a new minter address\r\n    /// @param _minter the new address\r\n    function setMinter(address _minter) external onlyOwner {\r\n        require(_minter != address(0), 'address not valid');\r\n        emit MinterUpdated(minter, _minter);\r\n        minter = _minter;\r\n    }\r\n\r\n    //-- View methods --\r\n    /// @notice returns token's decimals\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /// @notice returns available emissions for a specific timestamp\r\n    /// @param timestamp the moment in time to emit for\r\n    function availableForWeek(uint256 timestamp) external view returns (uint256) {\r\n        if (timestamp > block.timestamp) return 0;\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n        if (timestamp < emissionsStartTime) return 0;\r\n\r\n        int256 x = int256((timestamp - emissionsStartTime) / WEEK);\r\n        if (mintedInWeek[x] > 0) return 0;\r\n\r\n        return uint256(_computeEmissionPerWeek(x));\r\n    }\r\n\r\n    ///-- Write methods --\r\n    /// @notice returns the available emissions for a specific week\r\n    /// @param timestamp the moment in time to emit for\r\n    /// @dev formula: b(xe^(c-f(x))) where f(x)=x/a\r\n    function emitForWeek(uint256 timestamp) external whenNotPaused returns (uint256) {\r\n        if (timestamp != 0) {\r\n            require(emissionsStartTime < timestamp && timestamp <= block.timestamp, 'timestamp not valid');\r\n        } else {\r\n            timestamp = block.timestamp;\r\n        }\r\n        require(_getChainId() == governanceChainIdentifier, 'chain not valid');\r\n\r\n        int256 x = int256((timestamp - emissionsStartTime) / WEEK);\r\n        if (mintedInWeek[x] > 0) return 0;\r\n\r\n        uint256 emission = uint256(_computeEmissionPerWeek(x));\r\n        mintedInWeek[x] = emission;\r\n\r\n        _mint(address(this), emission);\r\n        emit Minted(msg.sender, address(this), emission);\r\n\r\n        return emission;\r\n    }\r\n\r\n    /// @notice extracts from the minted TAP\r\n    /// @param _to the receiver address\r\n    /// @param _amount TAP amount\r\n    function extractTAP(address _to, uint256 _amount) external whenNotPaused {\r\n        require(msg.sender == minter || msg.sender == owner(), 'unauthorized');\r\n        require(_amount > 0, 'amount not valid');\r\n\r\n        uint256 unclaimed = balanceOf(address(this));\r\n        require(unclaimed >= _amount, 'exceeds allowable amount');\r\n        _transfer(address(this), _to, _amount);\r\n    }\r\n\r\n    /// @notice burns TAP\r\n    /// @param _from the address to burn from\r\n    /// @param _amount TAP amount\r\n    function removeTAP(address _from, uint256 _amount) external whenNotPaused {\r\n        require(msg.sender == minter || msg.sender == owner(), 'unauthorized');\r\n        _burn(_from, _amount);\r\n        emit Burned(msg.sender, _from, _amount);\r\n    }\r\n\r\n    ///-- Private methods --\r\n    /// @notice Return the current chain ID.\r\n    /// @dev Useful for testing.\r\n    function _getChainId() private view returns (uint256) {\r\n        return block.chainid;\r\n    }\r\n\r\n    /// @notice returns the available emissions for a specific week\r\n    /// @dev formula: b(xe^(c-f(x))) where f(x)=x/a\r\n    /// @dev constants: a = 24, b = 2500, c = 3.7\r\n    /// @param x week number\r\n    function _computeEmissionPerWeek(int256 x) private view returns (int256 result) {\r\n        int256 fx = PRBMathSD59x18.fromInt(x).div(a_param);\r\n        int256 pow = c_param - fx;\r\n        result = ((b_param * x) * (PRBMathSD59x18.e().pow(pow)));\r\n    }\r\n}\r\n"
    },
    "prb-math/contracts/PRBMathSD59x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathSD59x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\nlibrary PRBMathSD59x18 {\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\n    int256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev Half the SCALE number.\n    int256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\n\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_WHOLE_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\n\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\n\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_WHOLE_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    int256 internal constant SCALE = 1e18;\n\n    /// INTERNAL FUNCTIONS ///\n\n    /// @notice Calculate the absolute value of x.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than MIN_SD59x18.\n    ///\n    /// @param x The number to calculate the absolute value for.\n    /// @param result The absolute value of x.\n    function abs(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x == MIN_SD59x18) {\n                revert PRBMathSD59x18__AbsInputTooSmall();\n            }\n            result = x < 0 ? -x : x;\n        }\n    }\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\n        // The operations can never overflow.\n        unchecked {\n            int256 sum = (x >> 1) + (y >> 1);\n            if (sum < 0) {\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\n                // right rounds down to infinity.\n                assembly {\n                    result := add(sum, and(or(x, y), 1))\n                }\n            } else {\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\n                // remainder gets truncated twice.\n                result = sum + (x & y & 1);\n            }\n        }\n    }\n\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function ceil(int256 x) internal pure returns (int256 result) {\n        if (x > MAX_WHOLE_SD59x18) {\n            revert PRBMathSD59x18__CeilOverflow(x);\n        }\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x > 0) {\n                    result += SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDiv\".\n    /// - None of the inputs can be MIN_SD59x18.\n    /// - The denominator cannot be zero.\n    /// - The result must fit within int256.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDiv\".\n    ///\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\n            revert PRBMathSD59x18__DivInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x and y.\n        uint256 ax;\n        uint256 ay;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n        }\n\n        // Compute the absolute value of (x*SCALE)÷y. The result must fit within int256.\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\n        if (rAbs > uint256(MAX_SD59x18)) {\n            revert PRBMathSD59x18__DivOverflow(rAbs);\n        }\n\n        // Get the signs of x and y.\n        uint256 sx;\n        uint256 sy;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n        }\n\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\n        // should be positive. Otherwise, it should be negative.\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (int256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\".\n    /// - For any x less than -41.446531673892822322, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp(int256 x) internal pure returns (int256 result) {\n        // Without this check, the value passed to \"exp2\" would be less than -59.794705707972522261.\n        if (x < -41_446531673892822322) {\n            return 0;\n        }\n\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathSD59x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            int256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - For any x less than -59.794705707972522261, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp2(int256 x) internal pure returns (int256 result) {\n        // This works because 2^(-x) = 1/2^x.\n        if (x < 0) {\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\n            if (x < -59_794705707972522261) {\n                return 0;\n            }\n\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n            unchecked {\n                result = 1e36 / exp2(-x);\n            }\n        } else {\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n            if (x >= 192e18) {\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\n            }\n\n            unchecked {\n                // Convert x to the 192.64-bit fixed-point format.\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\n\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\n                result = int256(PRBMath.exp2(x192x64));\n            }\n        }\n    }\n\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function floor(int256 x) internal pure returns (int256 result) {\n        if (x < MIN_WHOLE_SD59x18) {\n            revert PRBMathSD59x18__FloorUnderflow(x);\n        }\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x < 0) {\n                    result -= SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\n    /// of the radix point for negative numbers.\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\n    function frac(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x % SCALE;\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\n    function fromInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x < MIN_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__FromIntUnderflow(x);\n            }\n            if (x > MAX_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__FromIntOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\n    /// - x * y cannot be negative.\n    ///\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            int256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathSD59x18__GmOverflow(x, y);\n            }\n\n            // The product cannot be negative.\n            if (xy < 0) {\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = int256(PRBMath.sqrt(uint256(xy)));\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\n    function inv(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\n    function ln(int256 x) internal pure returns (int256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 195205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\n    function log10(int256 x) internal pure returns (int256 result) {\n        if (x <= 0) {\n            revert PRBMathSD59x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly mul operation, not the \"mul\" function defined in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            default {\n                result := MAX_SD59x18\n            }\n        }\n\n        if (result == MAX_SD59x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than zero.\n    ///\n    /// Caveats:\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\n    function log2(int256 x) internal pure returns (int256 result) {\n        if (x <= 0) {\n            revert PRBMathSD59x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n                assembly {\n                    x := div(1000000000000000000000000000000000000, x)\n                }\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\n\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\n            result = int256(n) * SCALE;\n\n            // This is y = x * 2^(-n).\n            int256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result * sign;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n            result *= sign;\n        }\n    }\n\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\n    /// fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is\n    /// always 1e18.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - None of the inputs can be MIN_SD59x18\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    ///\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\n            revert PRBMathSD59x18__MulInputTooSmall();\n        }\n\n        unchecked {\n            uint256 ax;\n            uint256 ay;\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\n            if (rAbs > uint256(MAX_SD59x18)) {\n                revert PRBMathSD59x18__MulOverflow(rAbs);\n            }\n\n            uint256 sx;\n            uint256 sy;\n            assembly {\n                sx := sgt(x, sub(0, 1))\n                sy := sgt(y, sub(0, 1))\n            }\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\n        }\n    }\n\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\n    function pi() internal pure returns (int256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - z cannot be zero.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : int256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - All from \"abs\" and \"PRBMath.mulDivFixedPoint\".\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\n        uint256 xAbs = uint256(abs(x));\n\n        // Calculate the first iteration of the loop in advance.\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        uint256 yAux = y;\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (yAux & 1 > 0) {\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\n            }\n        }\n\n        // The result must fit within the 59.18-decimal fixed-point representation.\n        if (rAbs > uint256(MAX_SD59x18)) {\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\n        }\n\n        // Is the base negative and the exponent an odd number?\n        bool isNegative = x < 0 && y & 1 == 1;\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\n    function scale() internal pure returns (int256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x cannot be negative.\n    /// - x must be less than MAX_SD59x18 / SCALE.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as a signed 59.18-decimal fixed-point .\n    function sqrt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            if (x < 0) {\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\n            }\n            if (x > MAX_SD59x18 / SCALE) {\n                revert PRBMathSD59x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\n        }\n    }\n\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}